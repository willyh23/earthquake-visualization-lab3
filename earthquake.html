<!DOCTYPE html>
<html lang="en-US">
 <head>
    <meta charset="utf-8">
    <title>Earthquake List</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <link href="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.css" rel="stylesheet">
    <script src="https://unpkg.com/maplibre-gl@2.4.0/dist/maplibre-gl.js"></script>
    <style>
        body {
      margin: 0;
      padding: 0;
    }

    #container {
      display: flex;
      height: 100vh;
      flex-direction: row;
      align-items: stretch;
    }

    #side-panel {
      flex-basis: 500px;
      overflow-y: scroll;
    }

    #map {
      flex-grow: 1;
    }

    button {
      margin-bottom: 10px;
    }

    table {
      border-collapse: collapse;
      border-spacing: 0;
      width: 100%;
      border: 1px solid #ddd;
    }

    th,
    td {
      text-align: left;
      padding: 16px;
    }

    tr:nth-child(even) {
      background-color: #f2f2f2;
    }
    </style>
 </head>
 <body>
    <main id="container">
        <div id="side-panel">

            <h2>Earthquake List</h2>
           <button>Sort by Magnitude</button>

           <table>
               <tr>
                   <th>id</th>
                   <th>magnitude</th>
                   <th>timestamp</th>
               </tr>
           </table>

        </div>
        <div id="map"></div>
    </main>

    <script>
    const map = new maplibregl.Map({
      container: 'map',
      center: [138, 38],
      zoom: 5.5,
      style: {
        "version": 8,
        "sources": {
          "satellite": {
            "type": "raster",
            "tiles": [
              "https://tiles.maps.eox.at/wmts/1.0.0/s2cloudless-2020_3857/default/g/{z}/{y}/{x}.jpg"
            ],
            "tileSize": 256
          }
        },
        "layers": [{
          "id": "satellite",
          "type": "raster",
          "source": "satellite"
        }]
      }
    });

async function geojsonFetch() {
    let response, earthquakes, japan;

    response = await fetch('assets/earthquakes.geojson');
    earthquakes = await response.json();

    response = await fetch('assets/japan.json');
    japan = await response.json();

    console.log("Earthquake data:", earthquakes);
    console.log("Japan boundary:", japan);

  map.on('load', function loadingData() {
   // Add earthquake points
   map.addSource('earthquakes', {
     type: 'geojson',
     data: earthquakes
   });

   map.addLayer({
     id: 'earthquakes-layer',
     type: 'circle',
     source: 'earthquakes',
     paint: {
       'circle-radius': 8,
       'circle-stroke-width': 2,
       'circle-color': 'red',
       'circle-stroke-color': 'white'
     }
   });

   // Add Japan polygon
   map.addSource('japan', {
     type: 'geojson',
     data: japan
   });

   map.addLayer({
     id: 'japan-layer',
     type: 'fill',
     source: 'japan',
     paint: {
       'fill-color': '#0080ff',
       'fill-opacity': 0.5
     }
   });
 });

 // âœ… Populate the table with earthquake data
 table = document.getElementsByTagName("table")[0];
 let row, cell1, cell2, cell3;

 for (let i = 0; i < earthquakes.features.length; i++) {
   row = table.insertRow(-1); // Add row at the end
   cell1 = row.insertCell(0);
   cell2 = row.insertCell(1);
   cell3 = row.insertCell(2);

   cell1.innerHTML = earthquakes.features[i].properties.id;
   cell2.innerHTML = earthquakes.features[i].properties.mag;
   cell3.innerHTML = new Date(earthquakes.features[i].properties.time).toLocaleDateString("en-US");
 }
}
geojsonFetch(); // Call the function

let btn = document.getElementsByTagName("button")[0];

btn.addEventListener('click', sortTable);

function sortTable(e) {
  let table, rows, switching, i, x, y, shouldSwitch;
  table = document.getElementsByTagName("table")[0];
  switching = true;

  while (switching) {
    switching = false;
    rows = table.rows;

    for (i = 1; i < (rows.length - 1); i++) {
      shouldSwitch = false;
      x = parseFloat(rows[i].getElementsByTagName("td")[1].innerHTML);
      y = parseFloat(rows[i + 1].getElementsByTagName("td")[1].innerHTML);

      if (x < y) {
        shouldSwitch = true;
        break;
      }
    }

    if (shouldSwitch) {
      rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
      switching = true;
    }
  }
}

</script>
</body>   
</html>    